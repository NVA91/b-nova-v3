"""
Image Classifier for b-nova-v3 AI Service
Uses PyTorch ResNet50 for image classification
"""

import io
import time
import logging
from typing import Tuple, List

import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image

logger = logging.getLogger(__name__)

class ImageClassifier:
    """Image classification using ResNet50"""
    
    def __init__(self, device: torch.device, model_name: str = 'resnet50'):
        """
        Initialize the image classifier
        
        Args:
            device: Torch device (cuda/cpu)
            model_name: Model architecture to use
        """
        self.device = device
        self.model_name = model_name
        self.model = None
        self.transform = None
        self.labels = None
        
        self._load_model()
        self._setup_transforms()
        self._load_labels()
        
    def _load_model(self):
        """Load pre-trained model"""
        logger.info(f"üì¶ Loading {self.model_name} model...")
        
        try:
            # Load pre-trained ResNet50
            self.model = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V2)
            
            # Set to evaluation mode
            self.model.eval()
            
            # Move to device
            self.model.to(self.device)
            
            logger.info(f"‚úÖ Model loaded on {self.device}")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to load model: {e}")
            raise
    
    def _setup_transforms(self):
        """Setup image preprocessing transforms"""
        self.transform = transforms.Compose([
            transforms.Resize(256),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize(
                mean=[0.485, 0.456, 0.406],
                std=[0.229, 0.224, 0.225]
            )
        ])
    
    def _load_labels(self):
        """Load ImageNet class labels"""
        # Simplified label list (top 10 for demo)
        # In production, load full ImageNet labels
        self.labels = [
            "tench", "goldfish", "great white shark", "tiger shark",
            "hammerhead", "electric ray", "stingray", "cock",
            "hen", "ostrich"
        ]
        
        logger.info(f"üìã Loaded {len(self.labels)} class labels")
    
    def preprocess_image(self, image_bytes: bytes) -> torch.Tensor:
        """
        Preprocess image for inference
        
        Args:
            image_bytes: Raw image bytes
            
        Returns:
            Preprocessed tensor
        """
        try:
            # Load image
            image = Image.open(io.BytesIO(image_bytes)).convert('RGB')
            
            # Apply transforms
            tensor = self.transform(image)
            
            # Add batch dimension
            tensor = tensor.unsqueeze(0)
            
            return tensor
            
        except Exception as e:
            logger.error(f"‚ùå Image preprocessing failed: {e}")
            raise
    
    def predict(self, image_bytes: bytes, top_k: int = 5) -> Tuple[List[dict], float]:
        """
        Perform image classification
        
        Args:
            image_bytes: Raw image bytes
            top_k: Number of top predictions to return
            
        Returns:
            Tuple of (predictions, inference_time)
        """
        try:
            # Preprocess image
            input_tensor = self.preprocess_image(image_bytes)
            input_tensor = input_tensor.to(self.device)
            
            # Perform inference
            start_time = time.time()
            
            with torch.no_grad():
                output = self.model(input_tensor)
                probabilities = torch.nn.functional.softmax(output[0], dim=0)
            
            inference_time = time.time() - start_time
            
            # Get top-k predictions
            top_probs, top_indices = torch.topk(probabilities, top_k)
            
            # Format results
            predictions = []
            for prob, idx in zip(top_probs, top_indices):
                predictions.append({
                    'class_id': int(idx),
                    'class_name': self._get_label(int(idx)),
                    'confidence': float(prob)
                })
            
            logger.info(f"‚úÖ Inference completed in {inference_time*1000:.2f}ms")
            
            return predictions, inference_time
            
        except Exception as e:
            logger.error(f"‚ùå Prediction failed: {e}")
            raise
    
    def _get_label(self, class_id: int) -> str:
        """
        Get class label for class ID
        
        Args:
            class_id: ImageNet class ID
            
        Returns:
            Class label
        """
        if class_id < len(self.labels):
            return self.labels[class_id]
        else:
            return f"class_{class_id}"
    
    def benchmark(self, num_iterations: int = 100) -> dict:
        """
        Benchmark inference performance
        
        Args:
            num_iterations: Number of inference iterations
            
        Returns:
            Benchmark results
        """
        logger.info(f"üèÉ Running benchmark ({num_iterations} iterations)...")
        
        # Create dummy input
        dummy_input = torch.randn(1, 3, 224, 224).to(self.device)
        
        # Warmup
        with torch.no_grad():
            for _ in range(10):
                _ = self.model(dummy_input)
        
        # Benchmark
        times = []
        with torch.no_grad():
            for _ in range(num_iterations):
                start = time.time()
                _ = self.model(dummy_input)
                times.append(time.time() - start)
        
        # Calculate statistics
        times = torch.tensor(times)
        results = {
            'iterations': num_iterations,
            'mean_ms': float(times.mean() * 1000),
            'std_ms': float(times.std() * 1000),
            'min_ms': float(times.min() * 1000),
            'max_ms': float(times.max() * 1000),
            'device': str(self.device)
        }
        
        logger.info(f"‚úÖ Benchmark complete: {results['mean_ms']:.2f}ms avg")
        
        return results
